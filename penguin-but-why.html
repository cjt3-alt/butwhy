<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>But Why - Penguin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Make canvas fill the entire window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let time = 0;

        // Hook day/night to local time
        function getDayAmount() {
            const now = new Date();
            const hours = now.getHours() + now.getMinutes() / 60;
            // Day: 6am-6pm (hours 6-18), Night: 6pm-6am
            if (hours >= 6 && hours <= 18) {
                // Daytime: peak at noon (12)
                return Math.sin((hours - 6) / 12 * Math.PI);
            } else {
                // Nighttime: return 0
                return 0;
            }
        }

        // Get sun position based on time (rises east/left at 6am, peaks noon, sets west/right at 6pm)
        function getSunPosition() {
            const now = new Date();
            const hours = now.getHours() + now.getMinutes() / 60;

            // Sun is only visible 6am-6pm
            if (hours < 6 || hours > 18) {
                return null; // Sun not visible
            }

            // Progress from 0 (6am) to 1 (6pm)
            const progress = (hours - 6) / 12;

            // X position: left (0.1) to right (0.9)
            const x = 0.1 + progress * 0.8;

            // Y position: arc across sky (lower at edges, highest at noon)
            // Using sine curve for natural arc
            const arcHeight = Math.sin(progress * Math.PI);
            const y = 0.6 - arcHeight * 0.5; // Range from 0.6 (horizon) to 0.1 (peak)

            return { x, y, progress };
        }

        // Get moon position based on time (rises east/left at 6pm, peaks midnight, sets west/right at 6am)
        function getMoonPosition() {
            const now = new Date();
            const hours = now.getHours() + now.getMinutes() / 60;

            // Moon is visible 6pm-6am
            // Convert to night progress (0 = 6pm, 0.5 = midnight, 1 = 6am)
            let progress;
            if (hours >= 18) {
                // 6pm to midnight: hours 18-24 maps to progress 0-0.5
                progress = (hours - 18) / 12;
            } else if (hours < 6) {
                // midnight to 6am: hours 0-6 maps to progress 0.5-1
                progress = 0.5 + hours / 12;
            } else {
                return null; // Moon not visible during day
            }

            // X position: left (0.1) to right (0.9)
            const x = 0.1 + progress * 0.8;

            // Y position: arc across sky
            const arcHeight = Math.sin(progress * Math.PI);
            const y = 0.6 - arcHeight * 0.5;

            return { x, y, progress };
        }

        // Stars - store as ratios for responsive sizing
        const stars = [];
        for (let i = 0; i < 200; i++) {
            stars.push({
                xRatio: Math.random(),
                yRatio: Math.random() * 0.5,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        // Aurora waves - matching the teal/green of the original (stored as ratios)
        const auroraWaves = [];
        for (let i = 0; i < 6; i++) {
            auroraWaves.push({
                yRatio: 0.07 + i * 0.04,
                amplitude: 25 + Math.random() * 35,
                frequency: 0.002 + Math.random() * 0.002,
                phase: Math.random() * Math.PI * 2,
                speed: 0.015 + Math.random() * 0.02,
                color: i % 3 === 2 ? 'purple' : 'green'
            });
        }

        // Mountain data - A breathtaking range worthy of being a national park
        // Each layer tells a story - unique, iconic silhouettes
        const mountainData = [
            // Layer 1: The Distant Sentinels - ancient peaks on the horizon
            // Asymmetric, mysterious, like guardians watching from afar
            { peakRatios: [
                [0, 0.38],
                [0.08, 0.28], [0.11, 0.34],  // Lone western sentinel
                [0.22, 0.36], [0.28, 0.32],  // Gentle ridge
                [0.35, 0.22],                 // The Watchtower - sharp dramatic spire
                [0.38, 0.34], [0.42, 0.3],
                [0.48, 0.16],                 // Cathedral Peak - iconic pointed summit
                [0.52, 0.28], [0.58, 0.24],
                [0.62, 0.14], [0.64, 0.18],  // Twin Fangs - two sharp peaks close together
                [0.67, 0.13],
                [0.72, 0.26], [0.8, 0.32],
                [0.88, 0.28], [0.94, 0.35],
                [1, 0.38]
            ], color: '#191928', snowLine: 0.45, hasSnow: true },

            // Layer 2: The Dark Towers - impossible spires of black rock (THE DREAMS)
            // These are what the penguin walks toward - unreachable, magnificent
            { peakRatios: [
                [0.44, 0.58],
                [0.48, 0.52], [0.51, 0.42],
                [0.54, 0.26],                 // The First Dream
                [0.57, 0.44],
                [0.61, 0.32], [0.64, 0.38],
                [0.67, 0.18],                 // The Impossible Peak - needle-thin spire
                [0.7, 0.34],
                [0.74, 0.24], [0.77, 0.28],
                [0.8, 0.11],                  // THE DREAM - tallest, most dramatic
                [0.83, 0.22],
                [0.87, 0.16],                 // Its companion spire
                [0.91, 0.32],
                [0.95, 0.38], [1, 0.5]
            ], color: '#12121f', snowLine: 0, hasSnow: false },

            // Layer 3: The Snow Giants - majestic snow-capped mountains
            // Broad, powerful, beautiful - the heart of the range
            { peakRatios: [
                [0, 0.52],
                [0.05, 0.46], [0.1, 0.5],
                [0.15, 0.38],                 // Mount Aurora - broad beautiful peak
                [0.22, 0.48], [0.26, 0.44],
                [0.32, 0.36],                 // The Great White
                [0.38, 0.42], [0.42, 0.46],
                [0.48, 0.5],                  // Valley
                [0.54, 0.44], [0.58, 0.48],
                [0.64, 0.42],
                [0.72, 0.52],                 // Rolling ridge
                [0.78, 0.46], [0.84, 0.5],
                [0.9, 0.54], [1, 0.56]
            ], color: '#282840', snowLine: 0.38, hasSnow: true },

            // Layer 4: The Foothills - sweeping snow dunes leading to the peaks
            // Gentle curves that draw the eye toward the mountains
            { peakRatios: [
                [0, 0.64],
                [0.12, 0.56],                 // Soft rise
                [0.25, 0.6],
                [0.35, 0.54],                 // Gentle crest
                [0.5, 0.58],
                [0.65, 0.52],                 // Another soft rise
                [0.8, 0.58],
                [0.92, 0.54],
                [1, 0.62]
            ], color: '#3a3a52', snowLine: 0.25, hasSnow: true },
        ];

        // Pre-calculate jagged snow edges (so they don't shake)
        const snowJaggedOffsets = {};
        mountainData.forEach((mountain, mIndex) => {
            snowJaggedOffsets[mIndex] = {};
            mountain.peakRatios.forEach((peak, pIndex) => {
                snowJaggedOffsets[mIndex][pIndex] = [];
                for (let j = 0; j <= 5; j++) {
                    snowJaggedOffsets[mIndex][pIndex].push((j % 2 === 0 ? 6 : -3) + Math.random() * 3);
                }
            });
        });

        // Convert ratios to actual pixel positions
        function getMountains() {
            return mountainData.map(m => ({
                peaks: m.peakRatios.map(([xr, yr]) => [xr * canvas.width, yr * canvas.height]),
                color: m.color,
                snowLine: m.snowLine,
                hasSnow: m.hasSnow !== false  // default true unless explicitly false
            }));
        }

        // Penguin state - positioned like in the original (lower left area)
        // Position will be calculated relative to canvas size
        const penguin = {
            walkPhase: 0,
            bodyBob: 0
        };

        function getPenguinPos() {
            return {
                x: canvas.width * 0.18,
                y: canvas.height * 0.65,
                scale: Math.min(canvas.width, canvas.height) / 1300
            };
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function getSkyGradient() {
            const dayAmount = getDayAmount();

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);

            // Night colors - deep purplish blue like the original
            const nightTop = [15, 18, 40];
            const nightMid = [25, 30, 55];
            const nightBottom = [45, 50, 75];

            // Day colors (gorgeous golden hour lighting)
            const dayTop = [120, 160, 210];
            const dayMid = [255, 190, 140];
            const dayBottom = [255, 210, 170];

            const topColor = nightTop.map((n, i) => Math.round(lerp(n, dayTop[i], dayAmount)));
            const midColor = nightMid.map((n, i) => Math.round(lerp(n, dayMid[i], dayAmount)));
            const bottomColor = nightBottom.map((n, i) => Math.round(lerp(n, dayBottom[i], dayAmount)));

            gradient.addColorStop(0, `rgb(${topColor.join(',')})`);
            gradient.addColorStop(0.5, `rgb(${midColor.join(',')})`);
            gradient.addColorStop(1, `rgb(${bottomColor.join(',')})`);

            return gradient;
        }

        function drawSky() {
            ctx.fillStyle = getSkyGradient();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawStars() {
            const dayAmount = getDayAmount();
            const starAlpha = 1 - dayAmount;

            if (starAlpha > 0.1) {
                stars.forEach(star => {
                    const twinkle = Math.sin(time * 0.05 + star.twinkle) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 255, 240, ${starAlpha * twinkle})`;
                    ctx.beginPath();
                    ctx.arc(star.xRatio * canvas.width, star.yRatio * canvas.height, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function drawSun() {
            const sunPos = getSunPosition();
            if (!sunPos) return; // Sun not visible

            const sunX = canvas.width * sunPos.x;
            const sunY = canvas.height * sunPos.y;
            const sunRadius = Math.min(canvas.width, canvas.height) * 0.06;

            // Sun intensity based on height (brighter when higher)
            const intensity = Math.sin(sunPos.progress * Math.PI);

            // Large warm glow
            const outerGlow = ctx.createRadialGradient(sunX, sunY, sunRadius * 0.5, sunX, sunY, sunRadius * 6);
            outerGlow.addColorStop(0, `rgba(255, 250, 200, ${0.8 * intensity})`);
            outerGlow.addColorStop(0.2, `rgba(255, 220, 150, ${0.5 * intensity})`);
            outerGlow.addColorStop(0.5, `rgba(255, 180, 100, ${0.2 * intensity})`);
            outerGlow.addColorStop(1, 'rgba(255, 150, 50, 0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 6, 0, Math.PI * 2);
            ctx.fill();

            // Inner bright glow
            const innerGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius * 2);
            innerGlow.addColorStop(0, `rgba(255, 255, 240, ${0.9})`);
            innerGlow.addColorStop(0.5, `rgba(255, 240, 180, ${0.6})`);
            innerGlow.addColorStop(1, 'rgba(255, 220, 150, 0)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius * 2, 0, Math.PI * 2);
            ctx.fill();

            // Sun disc - bright yellow/white
            const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);
            sunGradient.addColorStop(0, 'rgba(255, 255, 250, 1)');
            sunGradient.addColorStop(0.7, 'rgba(255, 245, 200, 1)');
            sunGradient.addColorStop(1, 'rgba(255, 220, 150, 1)');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMoon() {
            const moonPos = getMoonPosition();
            if (!moonPos) return; // Moon not visible

            const moonX = canvas.width * moonPos.x;
            const moonY = canvas.height * moonPos.y;
            const moonRadius = Math.min(canvas.width, canvas.height) * 0.08;

            // Moon brightness based on height in sky
            const moonAlpha = 0.7 + Math.sin(moonPos.progress * Math.PI) * 0.3;

            // Large atmospheric glow
            const outerGlow = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.3, moonX, moonY, moonRadius * 4.5);
            outerGlow.addColorStop(0, `rgba(255, 245, 180, ${0.6 * moonAlpha})`);
            outerGlow.addColorStop(0.3, `rgba(255, 230, 150, ${0.35 * moonAlpha})`);
            outerGlow.addColorStop(0.6, `rgba(200, 180, 120, ${0.15 * moonAlpha})`);
            outerGlow.addColorStop(1, 'rgba(200, 180, 120, 0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius * 4.5, 0, Math.PI * 2);
            ctx.fill();

            // Inner warm glow
            const innerGlow = ctx.createRadialGradient(moonX - moonRadius * 0.2, moonY, moonRadius * 0.5, moonX, moonY, moonRadius * 2);
            innerGlow.addColorStop(0, `rgba(255, 250, 200, ${0.7 * moonAlpha})`);
            innerGlow.addColorStop(0.5, `rgba(255, 240, 170, ${0.4 * moonAlpha})`);
            innerGlow.addColorStop(1, 'rgba(255, 230, 150, 0)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius * 2, 0, Math.PI * 2);
            ctx.fill();

            // Crescent moon - warm yellow
            ctx.fillStyle = `rgba(255, 248, 200, ${moonAlpha})`;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
            ctx.fill();

            // Cut out crescent shape
            const crescentOffset = moonRadius * 0.55;
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.beginPath();
            ctx.arc(moonX + crescentOffset, moonY - moonRadius * 0.15, moonRadius * 0.88, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Fill the cut with sky color
            ctx.fillStyle = getSkyGradient();
            ctx.beginPath();
            ctx.arc(moonX + crescentOffset, moonY - moonRadius * 0.15, moonRadius * 0.88, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawAurora() {
            const dayAmount = getDayAmount();

            // Aurora appears sparingly - uses slow sine waves to create periods of visibility
            // This creates ~30 second windows of aurora every few minutes
            const auroraPresence = Math.max(0, Math.sin(time * 0.001) * 1.5 - 0.3);
            if (auroraPresence <= 0) return; // No aurora right now

            // Gentle flickering when aurora is present
            const flicker = Math.sin(time * 0.015) * 0.15 + 0.85;
            const auroraAlpha = (1 - dayAmount) * auroraPresence * flicker * 0.7;

            if (auroraAlpha > 0.05) {
                const w = canvas.width;
                const h = canvas.height;

                // Only horizontal wave bands - no vertical rays
                auroraWaves.forEach((wave, waveIndex) => {
                    const waveY = wave.yRatio * h;
                    ctx.beginPath();
                    ctx.moveTo(0, waveY);

                    // Slower wave movement (reduced speed multiplier)
                    for (let x = 0; x <= w; x += 4) {
                        const y = waveY +
                            Math.sin(x * wave.frequency + time * wave.speed * 0.3 + wave.phase) * wave.amplitude +
                            Math.sin(x * wave.frequency * 1.7 + time * wave.speed * 0.25) * wave.amplitude * 0.4;
                        ctx.lineTo(x, y);
                    }

                    ctx.lineTo(w, waveY + 80);
                    ctx.lineTo(0, waveY + 80);
                    ctx.closePath();

                    const gradient = ctx.createLinearGradient(0, waveY - wave.amplitude, 0, waveY + 80);

                    const waveFlicker = Math.sin(time * 0.012 + waveIndex * 1.2) * 0.25 + 0.75;
                    const alpha = auroraAlpha * waveFlicker;

                    if (wave.color === 'green') {
                        // Teal-green like the original
                        gradient.addColorStop(0, `rgba(70, 230, 160, ${alpha * 0.7})`);
                        gradient.addColorStop(0.3, `rgba(50, 190, 130, ${alpha * 0.4})`);
                        gradient.addColorStop(0.6, `rgba(40, 150, 100, ${alpha * 0.15})`);
                        gradient.addColorStop(1, 'rgba(30, 120, 80, 0)');
                    } else {
                        // Subtle purple accents
                        gradient.addColorStop(0, `rgba(150, 100, 200, ${alpha * 0.5})`);
                        gradient.addColorStop(0.3, `rgba(120, 80, 170, ${alpha * 0.3})`);
                        gradient.addColorStop(0.6, `rgba(90, 60, 140, ${alpha * 0.1})`);
                        gradient.addColorStop(1, 'rgba(70, 40, 110, 0)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.fill();
                });
            }
        }

        function drawMountains() {
            const dayAmount = getDayAmount();
            const mountains = getMountains();

            mountains.forEach((mountain, mIndex) => {
                // Mountain body
                ctx.beginPath();
                ctx.moveTo(mountain.peaks[0][0], canvas.height);

                mountain.peaks.forEach((peak, i) => {
                    ctx.lineTo(peak[0], peak[1]);
                });

                ctx.lineTo(mountain.peaks[mountain.peaks.length - 1][0], canvas.height);
                ctx.closePath();

                // Mountain color with day/night variation
                const baseColor = mountain.color;
                const r = parseInt(baseColor.slice(1, 3), 16);
                const g = parseInt(baseColor.slice(3, 5), 16);
                const b = parseInt(baseColor.slice(5, 7), 16);

                // Day lighting - layers get progressively lighter/warmer for depth
                const depthFactor = mIndex * 20;
                const dayR = Math.min(255, r + 80 + depthFactor);
                const dayG = Math.min(255, g + 60 + depthFactor);
                const dayB = Math.min(255, b + 40 + depthFactor * 0.5);

                const finalR = Math.round(lerp(r, dayR, dayAmount));
                const finalG = Math.round(lerp(g, dayG, dayAmount));
                const finalB = Math.round(lerp(b, dayB, dayAmount));

                // Gradient for natural depth
                const minY = Math.min(...mountain.peaks.map(p => p[1]));
                const mountainGradient = ctx.createLinearGradient(0, minY, 0, canvas.height * 0.7);
                mountainGradient.addColorStop(0, `rgb(${Math.min(255, finalR + 15)}, ${Math.min(255, finalG + 12)}, ${Math.min(255, finalB + 10)})`);
                mountainGradient.addColorStop(1, `rgb(${finalR}, ${finalG}, ${finalB})`);

                ctx.fillStyle = mountainGradient;
                ctx.fill();

                // Only draw snow if this layer has snow
                if (mountain.hasSnow && mountain.snowLine > 0) {
                    mountain.peaks.forEach((peak, i) => {
                        if (i > 0 && i < mountain.peaks.length - 1) {
                            const prev = mountain.peaks[i - 1];
                            const next = mountain.peaks[i + 1];

                            // Draw snow on peaks (local maxima - where peak is higher than neighbors)
                            if (peak[1] < prev[1] && peak[1] < next[1]) {
                                const heightDiff = Math.min(prev[1], next[1]) - peak[1];
                                const snowHeight = heightDiff * mountain.snowLine;
                                const snowWidth = 15 + mIndex * 8 + (snowHeight * 0.2);

                                if (snowHeight > 5) {  // Only draw visible snow caps
                                    ctx.beginPath();
                                    ctx.moveTo(peak[0], peak[1]);

                                    // Left slope
                                    ctx.lineTo(peak[0] - snowWidth, peak[1] + snowHeight);

                                    // Jagged bottom edge
                                    const offsets = snowJaggedOffsets[mIndex]?.[i] || [5, -2, 6, -3, 5, -2];
                                    for (let j = 0; j <= 5; j++) {
                                        const jx = peak[0] - snowWidth + (snowWidth * 2 * j / 5);
                                        const jy = peak[1] + snowHeight + (offsets[j] || 0);
                                        ctx.lineTo(jx, jy);
                                    }

                                    ctx.lineTo(peak[0] + snowWidth, peak[1] + snowHeight);
                                    ctx.closePath();

                                    // Snow color - warmer during day
                                    const snowR = Math.round(lerp(180, 250, dayAmount));
                                    const snowG = Math.round(lerp(190, 248, dayAmount));
                                    const snowB = Math.round(lerp(210, 245, dayAmount));

                                    const snowGradient = ctx.createLinearGradient(peak[0], peak[1], peak[0], peak[1] + snowHeight);
                                    snowGradient.addColorStop(0, `rgb(${snowR}, ${snowG}, ${snowB})`);
                                    snowGradient.addColorStop(1, `rgb(${snowR - 20}, ${snowG - 15}, ${snowB - 5})`);

                                    ctx.fillStyle = snowGradient;
                                    ctx.fill();
                                }
                            }
                        }
                    });
                }
            });
        }

        function drawSnowGround() {
            const dayAmount = getDayAmount();
            const w = canvas.width;
            const h = canvas.height;

            // Main snow ground with perspective paths like the original
            const groundGradient = ctx.createLinearGradient(0, h * 0.5, 0, h);

            const nightSnow = [160, 170, 195];
            const daySnow = [235, 240, 250];

            const topSnow = nightSnow.map((n, i) => Math.round(lerp(n, daySnow[i], dayAmount)));
            const bottomSnow = nightSnow.map((n, i) => Math.round(lerp(n * 0.85, daySnow[i] * 0.95, dayAmount)));

            groundGradient.addColorStop(0, `rgb(${topSnow.join(',')})`);
            groundGradient.addColorStop(1, `rgb(${bottomSnow.join(',')})`);

            ctx.fillStyle = groundGradient;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.53);

            // Sweeping curves leading toward mountains (like paths in the original)
            ctx.quadraticCurveTo(w * 0.25, h * 0.58, w * 0.5, h * 0.51);
            ctx.quadraticCurveTo(w * 0.75, h * 0.44, w, h * 0.5);

            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();

            // Sweeping snow dunes creating depth - like paths winding toward mountains
            const dunes = [
                { startY: 0.6, midY: 0.56, endY: 0.58, color: 0.9 },
                { startY: 0.67, midY: 0.62, endY: 0.66, color: 0.85 },
                { startY: 0.76, midY: 0.72, endY: 0.74, color: 0.8 },
                { startY: 0.87, midY: 0.84, endY: 0.86, color: 0.75 },
            ];

            dunes.forEach((dune, i) => {
                ctx.beginPath();
                ctx.moveTo(0, h * dune.startY);

                // Create sweeping S-curves
                ctx.bezierCurveTo(
                    w * 0.25, h * dune.startY - 30 + Math.sin(i) * 20,
                    w * 0.5, h * dune.midY,
                    w * 0.75, h * dune.midY + 20
                );
                ctx.bezierCurveTo(
                    w * 0.875, h * dune.endY,
                    w * 0.94, h * dune.endY - 10,
                    w, h * dune.endY
                );

                ctx.lineTo(w, h);
                ctx.lineTo(0, h);
                ctx.closePath();

                const brightness = lerp(140 + i * 15, 220 + i * 8, dayAmount) * dune.color;
                const tint = lerp(150 + i * 12, 230 + i * 6, dayAmount) * dune.color;
                ctx.fillStyle = `rgb(${Math.round(brightness)}, ${Math.round(tint)}, ${Math.round(tint + 15)})`;
                ctx.fill();
            });

            // Add subtle shadow/highlight streaks to show the winding path
            ctx.strokeStyle = `rgba(${lerp(100, 180, dayAmount)}, ${lerp(110, 190, dayAmount)}, ${lerp(140, 220, dayAmount)}, 0.3)`;
            ctx.lineWidth = 3;

            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const offsetY = h * (0.58 + i * 0.055);
                ctx.moveTo(w * (0.06 + i * 0.03), offsetY + 30);
                ctx.quadraticCurveTo(w * 0.375, offsetY - 20, w * 0.69, offsetY);
                ctx.quadraticCurveTo(w * 0.875, offsetY + 10, w, offsetY - 10);
                ctx.stroke();
            }
        }

        function drawPenguin() {
            const pos = getPenguinPos();
            const baseX = pos.x;
            const baseY = pos.y;
            const scale = pos.scale;
            const walkPhase = penguin.walkPhase;
            const dayAmount = getDayAmount();

            ctx.save();
            ctx.translate(baseX, baseY);
            ctx.scale(scale, scale);

            // More realistic waddle motion
            const walkCycle = walkPhase * 0.7; // Slower, more deliberate steps
            const bodyBob = Math.sin(walkCycle * 2) * 4; // Up-down motion
            const bodySway = Math.sin(walkCycle) * 3; // Side-to-side waddle
            const bodyTilt = Math.sin(walkCycle) * 0.05; // Slight body rotation

            const x = bodySway;
            const y = bodyBob;

            // Leg positions - more pronounced stride
            const leftLegAngle = Math.sin(walkCycle) * 0.35;
            const rightLegAngle = Math.sin(walkCycle + Math.PI) * 0.35;
            const leftLegLift = Math.max(0, Math.sin(walkCycle)) * 5;
            const rightLegLift = Math.max(0, Math.sin(walkCycle + Math.PI)) * 5;

            // Moon illumination at night - warm glow on penguin
            const moonLight = 1 - dayAmount;
            const highlightColor = `rgba(255, 250, 220, ${moonLight * 0.3})`;

            // Shadow (softer at night due to moon glow)
            ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + dayAmount * 0.15})`;
            ctx.beginPath();
            ctx.ellipse(5, 85, 38, 10, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Apply body tilt for waddle
            ctx.save();
            ctx.rotate(bodyTilt);

            // Left leg
            ctx.save();
            ctx.translate(x - 10, y + 50 - leftLegLift);
            ctx.rotate(leftLegAngle);
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.ellipse(0, 15, 9, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            // Foot
            ctx.fillStyle = '#e88a2a';
            ctx.beginPath();
            ctx.ellipse(2, 28, 14, 7, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Right leg
            ctx.save();
            ctx.translate(x + 20, y + 50 - rightLegLift);
            ctx.rotate(rightLegAngle);
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.ellipse(0, 15, 9, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            // Foot
            ctx.fillStyle = '#e88a2a';
            ctx.beginPath();
            ctx.ellipse(-2, 28, 14, 7, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Body (black back visible since walking away)
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 5, y + 15, 30, 42, 0, 0, Math.PI * 2);
            ctx.fill();

            // Moon highlight on body (rim lighting at night)
            if (moonLight > 0.1) {
                const rimGradient = ctx.createRadialGradient(x + 35, y + 10, 0, x + 5, y + 15, 40);
                rimGradient.addColorStop(0, `rgba(255, 250, 220, ${moonLight * 0.25})`);
                rimGradient.addColorStop(0.5, `rgba(255, 250, 220, ${moonLight * 0.1})`);
                rimGradient.addColorStop(1, 'rgba(255, 250, 220, 0)');
                ctx.fillStyle = rimGradient;
                ctx.beginPath();
                ctx.ellipse(x + 5, y + 15, 32, 44, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // White belly edges (visible from behind)
            ctx.fillStyle = '#f0f0e8';
            ctx.beginPath();
            ctx.ellipse(x - 18, y + 15, 7, 32, 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 28, y + 15, 7, 32, -0.15, 0, Math.PI * 2);
            ctx.fill();

            // Left flipper with swing
            ctx.save();
            ctx.translate(x - 22, y);
            ctx.rotate(-0.25 + Math.sin(walkCycle + Math.PI) * 0.2); // Opposite to legs
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(0, 22, 11, 26, 0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Right flipper with swing
            ctx.save();
            ctx.translate(x + 32, y);
            ctx.rotate(0.25 + Math.sin(walkCycle) * 0.2); // Opposite to legs
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(0, 22, 11, 26, -0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Head (from behind) with slight bob
            const headBob = Math.sin(walkCycle * 2) * 2;
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 5, y - 32 + headBob, 20, 23, 0, 0, Math.PI * 2);
            ctx.fill();

            // Moon highlight on head
            if (moonLight > 0.1) {
                const headGlow = ctx.createRadialGradient(x + 20, y - 38 + headBob, 0, x + 5, y - 32 + headBob, 25);
                headGlow.addColorStop(0, `rgba(255, 250, 220, ${moonLight * 0.2})`);
                headGlow.addColorStop(1, 'rgba(255, 250, 220, 0)');
                ctx.fillStyle = headGlow;
                ctx.beginPath();
                ctx.ellipse(x + 5, y - 32 + headBob, 22, 25, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // White cheek patches visible from behind
            ctx.fillStyle = '#f0f0e8';
            ctx.beginPath();
            ctx.ellipse(x - 10, y - 30 + headBob, 5, 9, 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 20, y - 30 + headBob, 5, 9, -0.25, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore(); // body tilt
            ctx.restore(); // main transform
        }

        function drawText() {
            const dayAmount = getDayAmount();

            ctx.save();

            // Text settings - dramatic white font, centered on screen
            ctx.font = 'bold 72px Georgia, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const textX = canvas.width / 2;
            const textY = canvas.height - 120;

            // Multiple shadow layers for depth
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillText('but why?', textX + 3, textY + 3);

            // Soft outer glow
            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowBlur = 30;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('but why?', textX, textY);

            // Crisp main text
            ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ffffff';
            ctx.fillText('but why?', textX, textY);

            ctx.shadowBlur = 0;

            ctx.restore();
        }

        function animate() {
            time++;
            penguin.walkPhase += 0.06; // Slower, more realistic walk

            // Clear and draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawSky();
            drawStars();
            drawAurora();
            drawSun();
            drawMoon();
            drawMountains();
            drawSnowGround();
            drawPenguin();
            drawText();

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>
